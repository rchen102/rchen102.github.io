---
title: TCP 的三次握手
date: 2020-02-16 10:54:14
categories: 
tags:
---
### 传输控制协议 TCP
- 面向连接的、可靠的、基于字节流的传输层通信协议
- 将应用层的数据流分割成**报文段**（segment）并发送给目标节点的 TCP 层
- 数据包都有序号，对方收到则发送 ACK 确认，未收到则重传
- 使用校验来检验数据在传输时是否有错误

### TCP 报文
- 源端口号，目的地端口号：4 字节
- 序列号（Sequence Number）：每个字节都有序号，4 字节
- ACK确认号：期望收到对方下一个报文的第一个数据字节的序号，4 字节

### 三次握手
![三次握手](/img/Network/TCP3.png)
在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，采用 3 次握手建立一个连接

- 第一次握手：建立连接时，客户端发送 SYN 包 (seq=x) 到服务器，并进入 SYN_SEND 状态，等待服务器确认
- 第二次握手：服务器收到 SYN 包，必须确认客户的 SYN 包，即确认包 ACK (ack=x+1)，同时自己也发送一个 SYN 包 (seq=y)，即 SYN + ACK 包，此时服务器进入 SYN_RECV 状态
- 第三次握手：客户端收到服务器发送的 SYN+ACK 包，向服务器发送确认包 ACK (ack=y+1)，此包发送完毕，客户端进入 ESTABLISHED 状态，服务器收到确认包后，也进入该状态，三次握手完成
 
### 为什么需要三次握手才能建立连接
为了初始化 Sequence Number 的初始值（上面的 x 和 y），作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的问题而乱序

### 首次握手隐患 -- SYN 超时
问题起因：
- 服务器收到客户端的 SYN，回复 SYN-ACK 后未收到 ACK 确认
- 服务器不断重试直至超时（Linux 默认等待 63 秒断开连接，分别每隔 1、2、4、8、16 秒重新发送请求，最后一次请求发送完后等待 32 秒后才断开连接）
- 可能会导致服务器遭受 SYN Flood 的攻击，耗尽服务器 SYN 队列

应对措施：
- SYN 队列满后，通过 tcp_syncookies 参数回发 SYN Cookie
- 若为正常连接，则客户端会回发 SYN Cookie，直接建立连接

### 建立连接后，客户端出现故障？
保活机制：
- 在一段时间内（即保活时间），如果连接处于非活动状态，开启保活机制的一端，将向对方发送保活探测报文，如果未收到响应，则间隔一定时间，重新发送
- 直到尝试次数达到保活探测数上限，如果仍未收到响应，则中断连接