---
title: 散列表
date: 2020-02-21 09:40:00
categories: 
tags:
---
## 介绍
散列表也称哈希表，本质上是利用了数组支持按照下标随机访问的特性。基本元素是由键（Key）和值（Value）组成的键值对，通过散列函数将 Key 映射为下标，将 Value 存储在数组中对应下标的位置

## 散列冲突
不同 Key 被映射到相同的下标称为散列冲突，通常有以下解决方法

### 开放寻址法
**1. 线性探测**  
- 插入：如果发现位置已被占用，就从当前位置开始，依次向后查找空闲位置
- 查找：通过 Key 求出散列值后，比较对应元素的 Key 是否与要查找的 Key 相同，如相同则已经找到，如不同则继续向下线性查找，遇到第一个空闲位置时停止（可知元素不存在）
- 删除：不能仅仅将删除元素置空，因为可能会导致查找出错，可以将删除的元素标记为 deleted

随着散列表插入元素增多，散列冲突可能性越大，极端情况下可能需要探测整个散列表，因此最差复杂度为 O(n)

> 查找时，是以遇到空闲作为终止条件  
> - 给定 A 和 B 都映射到下标 X 上，A 先插入散列表，则 A 占据位置 X
> - B 接着插入散列表，占据位置 X + 1
> - 删除 A，将 X 置空
> - 此时如果查找 B，则会误判 B 不存在

**2. 二次探测**  
如果认为线性探测每次探测的步长为 1，探测序列为 hash(key)+0, hash(key)+1, hash(key)+2，则二次探测步长即为 hash(key)+0, hash(key)+1^2, hash(key)+2^2 ...

**3. 双重散列**  
使用多组散列函数，即存在 hash1(key), hash2(key), hash3(key) ...，使用时，先使用第一个散列函数，如果发现位置已被占用，再使用第二个散列函数，依次类推

---
### 链表法
使用链表法时，数组的每个位置可以视为一个「槽」，每个「槽」对应一条链表，当插入元素时，根据其散列值，找到对应的「槽」，将元素插入即可

此时插入时间复杂度为 O(1)，而查找、删除元素的复杂度取决于链表的长度 K，即 O(K)

::: warning 散列表碰撞攻击
通过精心设置的数据，使得所有数据经过散列后，都散列到同一个下标


:::