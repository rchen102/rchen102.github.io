---
title: 排序
date: 2020-02-10 09:29:00
categories: 
tags:
---
## 各种排序方法总结
| 排序方法 |  平均时间  | 最好时间 | 最差时间 | 空间复杂度 | 稳定性 |
| :--: | :--: | :--: | :--: | :--: | :--: |
| 冒泡排序 | O(n^2) | O(n) | O(n^2) | O(1) | 稳定 |

---
### 衡量排序算法效率的指标
**1. 算法的执行效率**
- 最好情况、最坏情况、平均情况时间复杂度：了解排序算法在各种数据情况下（有序，无序）的性能
- 时间复杂度的系数、常数、低阶：对于小规模数据，尤其重要
- 比较次数或交换、移动次数

**2. 算法的内存消耗**

**3. 算法的稳定性**

## O(n^2) 的排序算法
### 冒泡排序
比较相邻两个数据，看是否满足大小关系，如不满足，则交换。一次冒泡至少会让一个元素移动到应该的位置上，重复 n 次，就可以完成 n 个数据的排序工作。进一步优化：如果某次冒泡操作没有任何数据交换，则可知数据已经保持有序，可以提前退出

冒泡排序中包含两个操作原子，**比较和交换**。每交换一次，有序度（定义见下）加 1。对于给定数组，交换次数总是确定的，即为初始数组的逆序度，**也就是 n(n-1)/2 - 初始有序度**

**执行效率**
- 最优时间：排序数据本身已经有序，通过优化方法，只需要 O(n)
- 最坏时间：排序数据完全倒序排列，需要 O(n^2)
- 平均时间：通过有序度和逆序度分析，可知为 O(n^2)

::: tip 有序度与逆序度
- 有序度：数组中具有**有序**关系的**元素对**的个数。完全有序的数组，具有满有序度，为 n(n-1)/2
- 逆序度：数组中具有**逆序**关系的**元素对**的个数。**逆序度 = 满有序度 - 有序度**



对于给定 n 个数据进行冒泡排序，最坏情况下，初始有序度为 0，需要经过 n(n-1)/2 次交换。最好情况下，初始有序度即为满有序度，需要 0 次交换。取中间值 n(n-1)/4，作为平均需要的交换次数。而比较操作次数肯定大于等于交换次数，因而平均时间为 O(n^2)
:::

```java
public static void bubbleSort(int[] arr) {
    int n = arr.length;
    boolean flag;  // 本次冒泡是否有数据交换，用于判定是否提前退出
    for (int i = 0; i < n; i++) {
        flag = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j+1]) {
                int tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
                flag = true;
            }
        }
        if (!flag) break;
    }
}
```

### 插入排序
将数组中的数据分为两个区间，即**已排序区间**和**未排序区间**，初始已排序区间只包含第一个元素。核心思想：取未排序区间元素，在已排序区间中寻找合适位置插入

插入排序也包含两个操作，即**比较和移动**。