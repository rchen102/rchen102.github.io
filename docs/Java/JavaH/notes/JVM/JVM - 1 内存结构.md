---
title: JVM 内存结构
date: 2020-07-24 16:19:00
categories: 
tags:
---
## 介绍
首先需要注意，「内存结构」和「内存模型（JMM）」是两个不同的概念

JVM 内存结构分成了许多区域，如堆，方法区，虚拟机栈等等，需要注意，这些都是虚拟存在的，便于管理和理解 Java 程序内存

JVM 本身就是一个虚拟的机器，本质就是运行在系统上的一个 JVM 进程，在运行 Java 程序的时候，会将这些区域尽可能分配在硬件的寄存器或缓存上，以达到更高的速度

<div align=center>

![JVM内存映射](/img/Java/JVM内存映射.jpg)

</div>

## 内存结构详解（JDK1.8 以前）

JVM 执行程序的过程：Java 源码会被编译为字节码文件，然后由 JVM 中的类加载器加载，加载完毕后，交由 JVM 执行引擎执行

整个执行期间，JVM 会用一段空间来管理需要用到的数据和相关信息，这个空间被称为运行时数据区，也即 JVM 内存，本地接口则提供了 Java 与 OS 本地代码互相调用的功能

<div align=center>

<img src="/img/Java/JVM内存结构1.jpg" style="zoom:40%">

</div>

- JVM 内存结构总共分为五个区：虚拟机栈、本地方法栈、程序计数器、方法区、堆
- 其中**黄色**标记区域为线程**私有**，**绿色**区域为线程**共享**
- 不同区域占据大小不同，一般堆最大，程序计数器最小

---
### 堆
Java 堆被所有线程共享，在 JVM 启动时创建，主要用来存储对象实例本身和数组

堆是 JVM 管理的内存中最大的一块，也是 GC 发生的主要区域，因此也被称为 GC 堆

<div align=center>

<img src="/img/Java/Heap.png" style="zoom:65%">

</div>

- Java 堆的 GC 采用分代收集算法
- 主要分为新生代和老年代，新生代还可以细分为：Eden 空间，S0 空间，S1 空间
- Java 堆可以处于物理空间不连续，只要逻辑上连续即可，因此空间不足时，可以扩展
- 当堆中没有内存完成分配，堆本身也无法扩展时，会抛出 OutOfMemoryError

### 方法区
根据 JVM 规范，方法区被所有线程共享，主要存储的就是类的模板（堆存储类的实例）：已被 JVM 加载的类字节码、类的元数据、static-final 常量、static 变量、即时编译（JIT）后的代码等数据

JVM 规范中，方法区在 JVM 启动时创建，虽然方法区是堆的逻辑组成部分，但是别名是 non-heap，因此不要求在方法区实现 GC

JVM 规范只规定了有方法区这个概念和其作用，并没有规定如何去实现它，不同 JVM 有不同的实现方式

**不同版本 HotSpot JVM 方法区**：  
- JDK 1.7 前：采用永久代实现，把 GC 分代收集扩展至了方法区，运行时常量池（包含字符串常量池）也属于方法区
- JDK 1.7 及以后：字符串常量池，从永久代移动到 Java 堆内存， Class 实例（含静态变量）也已经移动到堆内存，符号引用转移到了 native heap 中
- JDK 1.8 及以后：替代永久代，新增元空间，使用本地（native）内存，不再受限于 JVM 本身分配的内存，减少了 OutOfMemoryError 出现的可能


<div align=center>

![JVM内存映射](/img/Java/MethodArea.png)

</div>


---
参考：

[1] [JVM——内存模型（三）：堆与方法区](https://blog.csdn.net/Searchin_R/article/details/84972579)