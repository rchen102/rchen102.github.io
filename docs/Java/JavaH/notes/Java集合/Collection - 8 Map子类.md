---
title: Map - 实现
date: 2020-07-09 10:23:00
categories: 
tags:
---
## HashMap
1. 基于数组实现  
- Node<K,V>[] table
- Node 是内部类，用于打包 key 和 value，同时也是链表法的节点

entry？？？？
map 遍历方法

key 的比较  
- 特别是自定义类，需要重写 hashCode 和 equals() 方法
- 先比较 hashCode()，如果相同再比较 equals()
(元素到底是如何插入的？哈希值到底用的哪个？)

1. 初始大小  
默认初始大小 16，如果事先知道数据量有多大，可以提前设置，减少动态扩容次数，提高性能

2. 装载因子和动态扩容  
- 最大装载因子 0.75，达到阈值就会启动扩容
- 每次扩容为原来的 2 倍

3. 散列冲突的解决  
底层采用链表法来解决冲突，在 JDK1.8 中，作了进一步优化，当链表长度太长超过 8 时，链表就会转换为红黑树，可以利用红黑树快速增删改查的特点提高 HashMap 的性能，当红黑树结点数少于 8 时，又会转化为链表（数据量较小时，红黑树要维持平衡，比起链表，性能优势并不明显）

4. 散列函数  
散列函数并不复杂，追求简单高效、分布均匀

5. null 值  
可以作为 key，也可以作为 value

## Hashtable
继承结构不同，since JDK1.0 非常老
线程安全
key 和 value 都不能为空
没有红黑树优化

## LinkedHashMap
有序 -> 按照插入顺序


## TreeMap
排序 -> 按照 key 排序

1. key 要实现 Comparable 接口

key 不能为 null 
