---
title: Java 内存模型
date: 2020-07-25 16:30:00
categories: 
tags:
---
## 内存模型背景
### 物理机并发问题
<div align=center>

<img src="/img/Java/JMMCPU.png" style="zoom:70%">

</div>

**1. 硬件效率问题**

CPU 无法仅仅依靠寄存器完成任务，需要与内存进行交互

然而内存读写速度与 CPU 的运算速度有数量级的差距，因此增加了一层高速缓存，作为作为内存和处理器之间的缓冲：算时，将需要用到的数据复制到缓存中，计算结束后，再从缓存中同步回主内存

**2. 缓存一致性问题**

对于多 CPU 系统（或多核 CPU），每个 CPU 内核都拥有自己的高速缓存，因此当多个线程同时涉及同一块内存区域时，可能导致各自的缓存数据不一致

为此，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，来维护缓存的一致性，比如 MESI 协议

**3. 重排序优化问题**

为了充分利用 CPU 内部运算单元，提高运行速度，编译器和处理器常常会对指令进行重排序：

- 编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序
- 指令级并行的重排序：现代 CPU 采用指令级并行技术，如果不存在数据依赖，可以多条指令重叠执行
- 内存系统的重排序：由于 CPU 使用缓存和读/写缓冲区，使得 load/store 操作看上去可能是在乱序执行

单核环境下，重排序是提高 CPU 运算速度的一种优化，可以保证运算结果与顺序执行相同

多核环境下，如果一个线程的计算任务依赖另一个线程计算任务的中间结果，且对相关数据读写没有任何防护措施，则代码的顺序性无法保证执行的顺序性，最终的结果也会不同于逻辑结果

<div align=center>

<img src="/img/Java/Reorder.png" style="zoom:100%">

</div>

## Java 内存模型
### JMM 基本概念
内存模型就是为了解决上述问题而提出的，是对内存和高速缓存读写访问的过程的抽象，不同系统和平台可能有不同的内存模型

JVM 规范中试图定义一种 Java 内存模型（JMM），来屏蔽掉各种硬件和操作系统的内存访问差异，保证 Java 程序在各个平台下都能达到一致的内存访问效果，不同于 C++，直接使用操作系统平台内存模型，导致同一代码在不同平台运行，可能存在并发问题

Java 内存模型和 JVM 内存模型，都是一种规范，属于不同层次的划分：Java 内存模型描述多线程运行时的内存间交互，为了程序可以正确并发执行；JVM 内存模型描述 JVM 的内存划分，为了便于管理和理解 Java 程序内存

更具体的说，JMM 主要是为了定义了程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节

此处的变量与 Java 编程中所说的变量有所区别，包括了实例字段、静态字段和构成数值对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的

### JMM 具体组成
<div align=center>

<img src="/img/Java/JMM.png" style="zoom:70%">

</div>

**1. 主内存**

JMM 规定所有的变量都存储在共同的主内存（Main Memory）中

此处主内存可以类比硬件的主内存，但是实际上仅仅是 JVM 内存的一部分

**2. 工作内存**

每个线程拥有自己的工作内存（Working Memory），工作内存中保存了被该线程使用到的变量的主内存副本拷贝

线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量

工作内存也属于抽象概念，涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化

### JMM 并发问题
**1. 数据一致性问题**

不同线程都拥有自己的工作内存，当多个线程的运算任务涉及同一共享变量时，各自的工作内存内共享变量的副本可能不一致，同步会主内存时，会出现问题

JMM 主要通过一系列的数据同步协议、规则来保证数据的一致性

**2. 重排序优化问题**

Java 中重排序，主要分为两类分别对应编译时和运行时，即编译期重排序和运行期重排序，重排序满足以下两个条件：

- 遵守 as - if - serial 语义，即单线程环境下，重排序的运行结果与顺序执行是相同的
- 不对存在数据依赖关系的指令进行重排序

## Java 内存间交互
<div align=center>

<img src="/img/Java/JMMAtom.png" style="zoom:80%">

</div>

关于主内存与工作内存交互，JMM 定义了 8 种基本操作，虚拟机实现时必须保证每种操作都是原子的，即不可再分的（对于 double/long 变量，load/sotre，read/write 操作在某些平台上允许有例外）：

| 操作 |  作用  | 
| :--: | :--: | 
| lock（锁定）| 将主内存变量加锁，标识为线程独占状态 |
| unlock（解锁） | 将主内存变量解锁，解锁后可被其他线程锁定 |
| read（读取） | 从主内存读取变量的值，传输到工作内存中，准备 load |
| load（载入） | 将变量的值写入工作内存 |
| use（使用） | 从工作内存读取数据来进行计算 |
| assign（赋值） | 将运算后的值重写存储到工作内存中 |
| store（存储） | 从工作内存读取变量的值，传输到主内存，准备 write |
| write（写入） | 将变量的值写入主内存 |

## Java 内存模型运行规则
### 三大特性
总的来说，JMM 一系列运行规则主要就是围绕原子性、可见性、有序性特征建立的

**1. 原子性**（Atomicity）

一个操作或者多个操作，要么全部执行完毕且过程中不会被打断，要么全都不执行

即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰

**2. 可见性**（Visibility）

多线程环境下，一个线程修改了共享变量的值，其他线程能够立即看到修改后的值

JMM 通过控制主内存与每个线程本地内存之间的交互，来为各个线程提供共享变量的可见性

**3. 有序性**（Ordering）

如果在本线程内观察，所有操作都是有序的，如果在一个线程中观察另一个线程，所有操作都是无序的

- 线程内：指令表现为按照串行方式（as - if - serial）执行
- 线程间：观察其他线程并发执行非同步的代码时，由于指令重排序优化，任何代码都可能交叉执行

Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性

### happens - before







我感觉就是在use这一步以后，将变量丢到了操作栈以后，你通知过来我的工作内存失效，也不影响我执行引擎继续执行，是不会重读的

重排序

顺序一致性

happens-before

as-if-serial

https://mubu.com/doc/2Q_5ufWdwPk

---
参考：

[1] [陈彩华 51CTO技术栈 | Java内存模型原理，你真的理解吗？](https://mp.weixin.qq.com/s/SvxHhkGu84rFXaWbeiAXQg  )

[2] [算法网 | JVM（十一）Java 内存模型](http://ddrv.cn/a/35646)

[3] [程序新视界 | JAVA内存模型(JMM)详解](https://www.choupangxia.com/2019/11/04/interview-jvm-gc-05/)

[4] [程序新视界 | Java内存模型相关原则详解](https://www.cnblogs.com/secbro/p/11804404.html)