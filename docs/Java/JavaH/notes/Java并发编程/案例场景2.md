---
title: 并发编程 用例
date: 2020-09-16 21:55:00
categories: 
tags:
---
## 死锁和活锁
```java
// 死锁
class Account {
    int balance = 100;

    void transfer(Account target, int amount) {
        synchronized (this) {
            synchronized (target) {
                if (amount <= balance) {
                    this.balance -= amount;
                    target.balance += amount;
                }
            }
        }
    }
}
// 活锁
class Account {
    int balance = 100;
    private Lock lock = new ReentrantLock();
    
    void transfer(Account target, int amount) {
        while (true) {
            if (this.lock.tryLock()) {
               try {
                   if (target.lock.tryLock()) {
                       try {
                           this.balance -= amount;
                           target.balance += amount;
                       } finally {
                           target.lock.unlock();
                       }
                   }
               } finally {
                   this.lock.unlock();
               }
            }
        }
    }
}
```

## 生产者-消费者（基于 Monitor）
```java
public class PCModel {
    final Lock lock = new ReentrantLock();
    final Condition notFull = lock.newCondition();
    final Condition notEmpty = lock.newCondition();

    Queue<String> queue = new LinkedList<>();

    int cap;

    public void add(String thing) {
        lock.lock();
        try {
            while (queue.size() == cap) {
                notFull.await();
            }
            queue.offer(thing);
            notEmpty.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    
    public String fetch() {
        lock.lock();
        try {
            while (queue.size() == 0) {
                notEmpty.await();
            }
            String thing = queue.poll();
            notFull.signal();
            return thing;
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        return "";
    }
}
```