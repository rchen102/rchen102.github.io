(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{401:function(v,t,_){"use strict";_.r(t);var a=_(25),r=Object(a.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"进程和线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程"}},[v._v("#")]),v._v(" 进程和线程")]),v._v(" "),_("p",[v._v("并行针对进程，是不同实体上的多个事件，并发针对线程，是在同⼀实体上的多个事件")]),v._v(" "),_("p",[_("strong",[v._v("进程：系统进行资源分配的基本单位")])]),v._v(" "),_("ul",[_("li",[v._v("每个进程拥有独立内存空间，进程间通信成本高")]),v._v(" "),_("li",[v._v("引入进程目的：多个程序并发执行，提高资源使用率、提高系统效率")]),v._v(" "),_("li",[v._v("缺点：进程在创建，切换和销毁时候开销比较大")])]),v._v(" "),_("p",[_("strong",[v._v("线程：CPU 进行调度的基本单位")])]),v._v(" "),_("ul",[_("li",[v._v("轻量级的进程，同一进程的线程共享：heap；独立：stack，程序计数器，一组寄存器")]),v._v(" "),_("li",[v._v("引入线程目的：同一进程里多线程共享虚拟内存空间和一些重要资源，线程间上下文切换和通信开销小，可以更好的利用多核 CPU 的性能，提高操作系统的并发性")])]),v._v(" "),_("h2",{attrs:{id:"线程相关的一些问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程相关的一些问题"}},[v._v("#")]),v._v(" 线程相关的一些问题")]),v._v(" "),_("p",[_("strong",[v._v("1. 并行一定比串行快吗")]),_("br"),v._v("\n不一定，特别是对单核 CPU，因为线程的创建和上下文切换也存在开销，进程和线程的上下文切换都涉及了内核和用户态的切换")]),v._v(" "),_("p",[_("strong",[v._v("2. 如何减少上下文切换")])]),v._v(" "),_("ul",[_("li",[v._v("无锁并发编程：多线程竞争锁时，会引起上下文切换")]),v._v(" "),_("li",[v._v("CAS 算法：Java Atomic 包使用 CAS 算法来更新数据，而不需要加锁")]),v._v(" "),_("li",[v._v("尽量使用最少的线程，避免创建不需要的线程")]),v._v(" "),_("li",[v._v("协程：在单线程里实现多任务的调度和切换")])]),v._v(" "),_("h2",{attrs:{id:"java-中的线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java-中的线程"}},[v._v("#")]),v._v(" Java 中的线程")]),v._v(" "),_("p",[v._v("Java 采用的是"),_("strong",[v._v("单线程编程模型")]),v._v("，Java 程序都运行在 JVM 中，程序中如果没有主动创建线程的话，只会创建一个线程，即主线程（不代表 JVM 中只有一个线程，JVM 在启动主线程时，也会启动一些其他线程，如 GC 线程）")]),v._v(" "),_("p",[_("strong",[v._v("用户线程和守护线程")]),v._v("：线程启动前，可以使用 "),_("code",[v._v("setDaemon(true)")]),v._v(" 设置为守护线程，默认用户线程")]),v._v(" "),_("ul",[_("li",[v._v("主要区别：是否阻止 JVM 正常退出（异常退出：例如 "),_("code",[v._v("System.exit(int status)")]),v._v(" 结束 JVM 进程）")]),v._v(" "),_("li",[v._v("只要还有用户线程在运行，JVM 不会退出；如果没有用户线程，都是守护线程，JVM 结束")]),v._v(" "),_("li",[v._v("主线程只是一个普通的用户线程，且 main() 方法开始执行时，线程已经启动，不能再被设为守护线程")])]),v._v(" "),_("hr"),v._v(" "),_("p",[_("strong",[v._v("参考")])]),v._v(" "),_("p",[v._v("[1] "),_("a",{attrs:{href:"https://www.cnblogs.com/mler/p/9453597.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("Java 线程类别，钩子线程"),_("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);