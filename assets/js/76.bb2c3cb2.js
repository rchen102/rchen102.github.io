(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{399:function(t,l,s){"use strict";s.r(l);var i=s(25),v=Object(i.a)({},(function(){var t=this,l=t.$createElement,s=t._self._c||l;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"arraylist"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arraylist"}},[t._v("#")]),t._v(" ArrayList")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("基于数组实现")])]),t._v(" "),s("li",[s("p",[t._v("构造方法")])])]),t._v(" "),s("ul",[s("li",[t._v("无参构造：使用已经创建好的，长度为 0 的空数组，new Object[0]")]),t._v(" "),s("li",[t._v("有参构造：创建指定容量大小数组，若为 0，则同样使用长度为 0 的空数组")])]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("数组扩容")])]),t._v(" "),s("ul",[s("li",[t._v("初始长度为 0，则扩容至大小为 10 的数组")]),t._v(" "),s("li",[t._v("否则，扩容为原来的 1.5 倍")]),t._v(" "),s("li",[t._v("扩容采用复制操作完成，耗时且产生垃圾，因此最好能够事先确定容量")])]),t._v(" "),s("h2",{attrs:{id:"linkedlist"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[t._v("#")]),t._v(" LinkedList")]),t._v(" "),s("ol",[s("li",[t._v("基于"),s("strong",[t._v("双向")]),t._v("链表实现")])]),t._v(" "),s("ul",[s("li",[t._v("存在一个内部类 Node")]),t._v(" "),s("li",[t._v("存在指向链表首部和尾部的指针：first 和 last")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("构造方法")])]),t._v(" "),s("ul",[s("li",[t._v("无参构造：初始化 size 为 0，之后每次有新结点加入，就创建一个节点")])]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("get 方法")])]),t._v(" "),s("ul",[s("li",[t._v("判断 index 是否大于 size/2，如果小于，则从 first 开始查询，如果大于，则从 last 开始")])])])}),[],!1,null,null,null);l.default=v.exports}}]);