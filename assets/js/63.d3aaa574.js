(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{223:function(t,_,v){"use strict";v.r(_);var a=v(0),s=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"传输控制协议-tcp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#传输控制协议-tcp"}},[t._v("#")]),t._v(" 传输控制协议 TCP")]),t._v(" "),v("ul",[v("li",[t._v("面向连接的、可靠的、基于字节流的传输层通信协议")]),t._v(" "),v("li",[t._v("将应用层的数据流分割成"),v("strong",[t._v("报文段")]),t._v("（segment）并发送给目标节点的 TCP 层")]),t._v(" "),v("li",[t._v("数据包都有序号，对方收到则发送 ACK 确认，未收到则重传")]),t._v(" "),v("li",[t._v("使用校验来检验数据在传输时是否有错误")])]),t._v(" "),v("h3",{attrs:{id:"tcp-报文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-报文"}},[t._v("#")]),t._v(" TCP 报文")]),t._v(" "),v("ul",[v("li",[t._v("源端口号，目的地端口号：4 字节")]),t._v(" "),v("li",[t._v("序列号（Sequence Number）：每个字节都有序号，4 字节")]),t._v(" "),v("li",[t._v("ACK确认号：期望收到对方下一个报文的第一个数据字节的序号，4 字节")])]),t._v(" "),v("h3",{attrs:{id:"三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/Network/TCP3.png",alt:"三次握手"}}),t._v("\n在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，采用 3 次握手建立一个连接")]),t._v(" "),v("ul",[v("li",[t._v("第一次握手：建立连接时，客户端发送 SYN 包 (seq=x) 到服务器，并进入 SYN_SEND 状态，等待服务器确认")]),t._v(" "),v("li",[t._v("第二次握手：服务器收到 SYN 包，必须确认客户的 SYN 包，即确认包 ACK (ack=x+1)，同时自己也发送一个 SYN 包 (seq=y)，即 SYN + ACK 包，此时服务器进入 SYN_RECV 状态")]),t._v(" "),v("li",[t._v("第三次握手：客户端收到服务器发送的 SYN+ACK 包，向服务器发送确认包 ACK (ack=y+1)，此包发送完毕，客户端进入 ESTABLISHED 状态，服务器收到确认包后，也进入该状态，三次握手完成")])]),t._v(" "),v("h3",{attrs:{id:"为什么需要三次握手才能建立连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要三次握手才能建立连接"}},[t._v("#")]),t._v(" 为什么需要三次握手才能建立连接")]),t._v(" "),v("p",[t._v("为了初始化 Sequence Number 的初始值（上面的 x 和 y），作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的问题而乱序")]),t._v(" "),v("h3",{attrs:{id:"首次握手隐患-syn-超时"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#首次握手隐患-syn-超时"}},[t._v("#")]),t._v(" 首次握手隐患 -- SYN 超时")]),t._v(" "),v("p",[t._v("问题起因：")]),t._v(" "),v("ul",[v("li",[t._v("服务器收到客户端的 SYN，回复 SYN-ACK 后未收到 ACK 确认")]),t._v(" "),v("li",[t._v("服务器不断重试直至超时（Linux 默认等待 63 秒断开连接，分别每隔 1、2、4、8、16 秒重新发送请求，最后一次请求发送完后等待 32 秒后才断开连接）")]),t._v(" "),v("li",[t._v("可能会导致服务器遭受 SYN Flood 的攻击，耗尽服务器 SYN 队列")])]),t._v(" "),v("p",[t._v("应对措施：")]),t._v(" "),v("ul",[v("li",[t._v("SYN 队列满后，通过 tcp_syncookies 参数回发 SYN Cookie")]),t._v(" "),v("li",[t._v("若为正常连接，则客户端会回发 SYN Cookie，直接建立连接")])]),t._v(" "),v("h3",{attrs:{id:"建立连接后，客户端出现故障？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#建立连接后，客户端出现故障？"}},[t._v("#")]),t._v(" 建立连接后，客户端出现故障？")]),t._v(" "),v("p",[t._v("保活机制：")]),t._v(" "),v("ul",[v("li",[t._v("在一段时间内（即保活时间），如果连接处于非活动状态，开启保活机制的一端，将向对方发送保活探测报文，如果未收到响应，则间隔一定时间，重新发送")]),t._v(" "),v("li",[t._v("直到尝试次数达到保活探测数上限，如果仍未收到响应，则中断连接")])])])}),[],!1,null,null,null);_.default=s.exports}}]);