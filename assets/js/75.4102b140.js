(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{410:function(t,e,a){"use strict";a.r(e);var v=a(25),r=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"高速缓存与缓存一致性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高速缓存与缓存一致性"}},[t._v("#")]),t._v(" 高速缓存与缓存一致性")]),t._v(" "),a("div",{attrs:{align:"center"}},[a("img",{staticStyle:{zoom:"70%"},attrs:{src:"/img/Java/JMMCPU.png"}})]),t._v(" "),a("p",[t._v("传统计算机架构中，CPU 并不是直接从主内存中读写数据，而是在 CPU 和主内存直接，增加了高速缓存。计算时，将需要用到的数据复制到缓存中，计算结束后，再从缓存中同步回主内存")]),t._v(" "),a("p",[t._v("对于多 CPU 系统（或多核），每个处理器内核都拥有自己的高速缓存，但是又共同操作同一块主内存，因此当多个线程同时涉及同一块内存区域时，可能导致各自的缓存数据不一致，因此读写时需要遵从一定的协议，来维护缓存一致性")]),t._v(" "),a("h2",{attrs:{id:"jmm-基本介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jmm-基本介绍"}},[t._v("#")]),t._v(" JMM 基本介绍")]),t._v(" "),a("p",[t._v("JVM 规范中试图定义一种 Java 内存模型（JMM），来屏蔽掉各种硬件和操作系统的内存访问差异，保证 Java 程序在各个平台下都能达到一致的内存访问效果（不同于 C，C++，直接使用物理硬件和操作系统的内存模型，导致同一代码在不同平台，可能存在并发问题）")]),t._v(" "),a("p",[a("strong",[t._v("JMM 定义了程序中变量的访问规则（多线程与内存交互的规则")]),t._v("）")]),t._v(" "),a("blockquote",[a("p",[t._v("JMM 规定所有的变量都存储在主内存（Main Memory）中。每条线程拥有自己的工作内存（Working Memory），工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成")])]),t._v(" "),a("div",{attrs:{align:"center"}},[a("img",{staticStyle:{zoom:"70%"},attrs:{src:"/img/Java/JMM.png"}})]),t._v(" "),a("ul",[a("li",[t._v("此处变量是指共享变量，即实例字段、静态字段、构成数组对象的元素，不包括局部变量、方法参数等线程私有变量")]),t._v(" "),a("li",[t._v("JMM 本身只是一种规范，工作内存和主内存都是抽象的概念，并不真实存在，但是通常可以认为，主内存就是硬件的内存，工作内存优先存储于寄存器和高速缓存中")]),t._v(" "),a("li",[a("code",[t._v("volatile")]),t._v(" 变量依然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般，因此这里的描述对于 "),a("code",[t._v("volatile")]),t._v(" 也并不存在例外")])]),t._v(" "),a("hr"),t._v(" "),a("p",[a("strong",[t._v("JMM 与 JVM 内存结构都是一种规范，但是属于不同层次的内存划分")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("JMM 主要描述了多线程执行时的内存使用方式，为了程序可以正确并发执行；JVM 内存结构主要是为了便于管理和理解 Java 程序内存")]),t._v(" "),a("li",[t._v("JMM 中的工作内存和主内存，是对 CPU 寄存器、高速缓存和硬件内存的抽象描述；JVM 内存结构只是一种对 JVM 内存的物理划分（JVM 作为一个程序，内存具体会被分配到哪里是不确定的）")])]),t._v(" "),a("h2",{attrs:{id:"内存间交互操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存间交互操作"}},[t._v("#")]),t._v(" 内存间交互操作")]),t._v(" "),a("div",{attrs:{align:"center"}},[a("img",{staticStyle:{zoom:"80%"},attrs:{src:"/img/Java/JMMAtom.png"}})]),t._v(" "),a("p",[t._v("关于工作内存与主内存交互，JMM 定义了 8 种基本操作，JVM 实现必须保证每一种操作都是原子的（double 和 long 类型的变量，在某些实现平台上允许有例外）：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("操作")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("作用")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("lock（锁定）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("将主内存变量加锁，标识为线程独占状态")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("unlock（解锁）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("将主内存变量解锁，解锁后可被其他线程锁定")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("read（读取）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("从主内存读取变量的值，传输到工作内存中，准备 load")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("load（载入）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("将变量的值写入工作内存")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("use（使用）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("从工作内存读取数据来进行计算")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("assign（赋值）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("将运算后的值重写存储到工作内存中")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("store（存储）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("从工作内存读取变量的值，传输到主内存，准备 write")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("write（写入）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("将变量的值写入主内存")])])])]),t._v(" "),a("p",[t._v("三大特性")]),t._v(" "),a("p",[t._v("我感觉就是在use这一步以后，将变量丢到了操作栈以后，你通知过来我的工作内存失效，也不影响我执行引擎继续执行，是不会重读的")]),t._v(" "),a("p",[t._v("重排序")]),t._v(" "),a("p",[t._v("顺序一致性")]),t._v(" "),a("p",[t._v("happens-before")]),t._v(" "),a("p",[t._v("as-if-serial")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("参考：")]),t._v(" "),a("p",[t._v("[1] "),a("a",{attrs:{href:"http://ddrv.cn/a/35646",target:"_blank",rel:"noopener noreferrer"}},[t._v("算法网 | JVM（十一）Java 内存模型"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("[2] "),a("a",{attrs:{href:"https://www.choupangxia.com/2019/11/04/interview-jvm-gc-05/",target:"_blank",rel:"noopener noreferrer"}},[t._v("程序新视界 | JAVA内存模型(JMM)详解"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("[3] "),a("a",{attrs:{href:"https://www.cnblogs.com/secbro/p/11804404.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("程序新视界 | Java内存模型相关原则详解"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);