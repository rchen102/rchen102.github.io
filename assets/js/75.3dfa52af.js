(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{377:function(t,v,_){"use strict";_.r(v);var r=_(25),l=Object(r.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"arraylist"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#arraylist"}},[t._v("#")]),t._v(" ArrayList")]),t._v(" "),_("p",[_("strong",[t._v("1. 基于动态数组实现")])]),t._v(" "),_("p",[_("strong",[t._v("2. 构造方法")])]),t._v(" "),_("ul",[_("li",[t._v("无参构造：使用已经创建好的，长度为 0 的空数组，new Object[0]")]),t._v(" "),_("li",[t._v("有参构造：创建指定容量大小数组，若参数为 0，则同无参构造")]),t._v(" "),_("li",[t._v("有参构造：参数为集合，则使用 Arrays.copyOf 复制创建数组")])]),t._v(" "),_("p",[_("strong",[t._v("3. 数组扩容")])]),t._v(" "),_("ul",[_("li",[t._v("初始长度为 0，则默认扩容至大小为 10 的数组")]),t._v(" "),_("li",[t._v("否则，扩容为原来的 1.5 倍")]),t._v(" "),_("li",[t._v("扩容采用 Arrays.copyOf 复制操作完成，耗时且产生垃圾，因此最好能够事先确定容量")])]),t._v(" "),_("p",[_("strong",[t._v("4. 删除操作")])]),t._v(" "),_("ul",[_("li",[t._v("删除元素后，复制数组至新的位置填补空白，同时在末尾补上对应的 null（这样 GC 时可以删除）")])]),t._v(" "),_("p",[_("strong",[t._v("5. 序列化")])]),t._v(" "),_("ul",[_("li",[t._v("ArrayList 中使用 transient 修饰数组，但是内部实现了 readObject 和 writeObject")]),t._v(" "),_("li",[t._v("目的在于，扩容操作会留下空白数组，如果直接序列化会浪费空间")])]),t._v(" "),_("h2",{attrs:{id:"linkedlist"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[t._v("#")]),t._v(" LinkedList")]),t._v(" "),_("p",[_("strong",[t._v("1. 基于双向链表实现")])]),t._v(" "),_("ul",[_("li",[t._v("存在一个静态内部类 Node，包含 next，prev 和 item 三个字段")]),t._v(" "),_("li",[t._v("存在指向链表首部和尾部的指针，便于操作：first 和 last")])]),t._v(" "),_("p",[_("strong",[t._v("2. 构造方法")])]),t._v(" "),_("ul",[_("li",[t._v("不能指定初始容量，链表无需提前分配空间")]),t._v(" "),_("li",[t._v("有参构造：参数为集合，集合转为 Array，遍历数组，创建双向链表")])]),t._v(" "),_("p",[_("strong",[t._v("3. 核心方法 node(index)")])]),t._v(" "),_("ul",[_("li",[t._v("该方法在集合中多次出现，获得下标对应的结点")]),t._v(" "),_("li",[t._v("优化：如果索引小于 size/2，从前向后遍历，否则，从后向前遍历")])])])}),[],!1,null,null,null);v.default=l.exports}}]);