(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{235:function(t,v,_){"use strict";_.r(v);var s=_(0),r=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"基本定义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本定义"}},[t._v("#")]),t._v(" 基本定义")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("节点的高度")]),t._v("：节点到叶子节点的最长路径")]),t._v(" "),_("li",[_("strong",[t._v("节点的深度")]),t._v("：根节点到该节点的路径")]),t._v(" "),_("li",[_("strong",[t._v("节点的层数")]),t._v("：节点的深度 + 1")]),t._v(" "),_("li",[_("strong",[t._v("树的高度")]),t._v("：根节点的高度")])]),t._v(" "),_("h2",{attrs:{id:"二叉树的分类和存储"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的分类和存储"}},[t._v("#")]),t._v(" 二叉树的分类和存储")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("满二叉树")]),t._v("：除叶子节点外，每个节点都有左右子树")]),t._v(" "),_("li",[_("strong",[t._v("完全二叉树")]),t._v("：叶子节点只出现在最下面两层，且最后一层叶子节点都紧密靠左排列，除了最后一层，其他层节点个数达到最大")])]),t._v(" "),_("hr"),t._v(" "),_("p",[_("strong",[t._v("存储方法")]),t._v("：主要分为基于链表的"),_("strong",[t._v("链式存")]),t._v("储和基于数组的"),_("strong",[t._v("顺序存储")])]),t._v(" "),_("p",[t._v("对于顺序存储，根节点存储在下标 "),_("code",[t._v("i=1")]),t._v(" 的位置，对于任意节点 "),_("code",[t._v("i")]),t._v("，其左节点为 "),_("code",[t._v("2i")]),t._v("，右节点为 "),_("code",[t._v("2i+1")]),t._v("，父节点为 "),_("code",[t._v("i/2")])]),t._v(" "),_("p",[t._v("完全二叉树天然适合于顺序存储，除了下标为 0 的位置，能够充分利用所有的内存空间")]),t._v(" "),_("h2",{attrs:{id:"二叉搜索树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二叉搜索树"}},[t._v("#")]),t._v(" 二叉搜索树")]),t._v(" "),_("p",[t._v("树的任意一个节点，其左子树中的每个节点值都小于该节点，其右子树中的每个节点值都大于该节点，且左右子树也满足二叉搜索树的定义")]),t._v(" "),_("div",{staticClass:"custom-block warning"},[_("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),_("p",[t._v("判断二叉搜索树时，不能仅仅判断左右子节点是否满足「左小右大」，一定要注意是整个左子树和整个右子树")])])])}),[],!1,null,null,null);v.default=r.exports}}]);