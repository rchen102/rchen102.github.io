(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{369:function(s,a,e){"use strict";e.r(a);var t=e(25),n=Object(t.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("ul",[e("li",[s._v("HashMap：基于"),e("strong",[s._v("数组")]),s._v("，"),e("strong",[s._v("单链表")]),s._v("，"),e("strong",[s._v("红黑树")]),s._v("，无序，线程不安全")]),s._v(" "),e("li",[s._v("Hashtable：基于"),e("strong",[s._v("数组")]),s._v("，"),e("strong",[s._v("单链表")]),s._v("，无序，线程安全")]),s._v(" "),e("li",[s._v("LinkedHashMap：基于 "),e("strong",[s._v("HashMap")]),s._v("，"),e("strong",[s._v("双向链表")]),s._v("，按插入顺序或访问顺序，线程不安全")]),s._v(" "),e("li",[s._v("TreeMap")]),s._v(" "),e("li",[s._v("ConcurrentHashMap")])]),s._v(" "),e("details",[e("summary",[s._v("定义")]),s._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// since JDK 1.2")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("HashMap")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("K")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("​"),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("V")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("extends")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("AbstractMap")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("K")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("​"),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("V")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("implements")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Map")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("K")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("​"),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("V")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Cloneable")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Serializable")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// since JDK 1.0")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Hashtable")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("K")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("​"),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("V")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("extends")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Dictionary")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("K")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("​"),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("V")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("implements")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Map")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("K")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("​"),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("V")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Cloneable")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Serializable")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// since JDK 1.4")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("LinkedHashMap")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("K")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("​"),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("V")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("extends")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("HashMap")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("K")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("​"),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("V")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("implements")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Map")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("K")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("​"),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("V")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br")])])]),s._v(" "),e("h2",{attrs:{id:"hashmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[s._v("#")]),s._v(" HashMap")]),s._v(" "),e("ol",[e("li",[e("p",[s._v("基于数组，单链表，红黑树实现，数组的一个位置称为桶"),e("br"),s._v("\n(1) 基本结点 Node<K,V> 实现了 Map.Entry<K,V> 接口"),e("br"),s._v("\n(2) 结点存储了 hash，key，value，next")])]),s._v(" "),e("li",[e("p",[s._v("默认初始容量 "),e("code",[s._v("16")]),s._v("，装载因子 "),e("code",[s._v("0.75")]),s._v("，容量总是保持 "),e("code",[s._v("2^n")]),s._v("（方便按位与操作取模）"),e("br"),s._v("\n(1) 如传入容量参数 k，默认向上拓展至 k 最近的 "),e("code",[s._v("2^n")]),s._v(" 作为容量"),e("br"),s._v("\n(2) 懒加载：HashMap 被首次使用时，才进行初始化开辟空间")])]),s._v(" "),e("li",[e("p",[s._v("key 比较：先通过 hashCode() 找到对应的桶，如相同再比较 equals()"),e("br"),s._v("\n(1) 因此自定义类要注意同时重写两个方法"),e("br"),s._v("\n(2) "),e("code",[s._v("null")]),s._v(" 可以作为 key 和 value 使用")])]),s._v(" "),e("li",[e("p",[s._v("查找，修改的平均时间复杂度为 "),e("code",[s._v("O(1)")]),e("br"),s._v("\n(1) 数组查询效率 "),e("code",[s._v("O(1)")]),s._v("，链表查询效率 "),e("code",[s._v("O(k)")]),s._v("，红黑树查询效率 "),e("code",[s._v("O(logk)")]),s._v("，k 为桶中元素个数")])]),s._v(" "),e("li",[e("p",[s._v("插入操作 put()：通过 hash(key) 方法得到 hash 值，再由 hash 值计算索引"),e("br"),s._v("\n(1) 哈希值：由 key 的 hashCode 计算，高 16 位不变，低 16 位与高 16 位做一次异或运算，这样通过按位与取模时，高 16 位也能参与散列"),e("br"),s._v("\n(2) 索引：采用高效的按位与操作，index = (n - 1) & hash()，n 是容量")])]),s._v(" "),e("li",[e("p",[s._v("扩容操作 resize()：每次扩容为原来 "),e("code",[s._v("2 倍")]),e("br"),s._v("\n(1) 由取模算法可知，扩容后元素的桶位置只有两种可能：原位置 or 原位置 + oldCap"),e("br"),s._v("\n(2) 此时会对桶中的链表或红黑树进行拆分，分成以上两类")])]),s._v(" "),e("li",[e("p",[s._v("树化操作 treeifyBin()：发生在插入新元素时，当单个桶中元素数量 "),e("code",[s._v(">= 8")]),s._v(" 时发生"),e("br"),s._v("\n(1) 若此时，桶的数量 "),e("code",[s._v("< 64")]),s._v(" ，扩容代替树化操作"),e("br"),s._v("\n(2) 若此时，桶的数量 "),e("code",[s._v(">= 64")]),s._v("，树化操作进行"),e("br"),s._v("\n(3) 链表过长时，查找效率低下，可以利用红黑树快速增删改查的特点提高性能"),e("br"),s._v("\n(4) 但是当红黑树中结点太少时，红黑树要维持平衡，比起链表，性能优势并不明显"),e("br"),s._v("\n(5) 因此当桶数量 "),e("code",[s._v("< 64")]),s._v("，即容量较小时，哈希碰撞的几率会比较大，此时应优先扩容")])]),s._v(" "),e("li",[e("p",[s._v("反树化操作 untreeify()：发生在删除 remove() 和扩容 resize() 中"),e("br"),s._v("\n(1) 当 resize() 拆分红黑树时，拆分后，若发现单个桶中元素数量 "),e("code",[s._v("<= 6")]),s._v("，进行反树化"),e("br"),s._v("\n(2) 当 remove() 是从红黑树中删除结点时，如果发现根或左右结点其一为空，说明结点过少 "),e("code",[s._v("<= 2")]),s._v("，转为链表")])])]),s._v(" "),e("h2",{attrs:{id:"hashtable"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashtable"}},[s._v("#")]),s._v(" Hashtable")]),s._v(" "),e("p",[s._v("Hashtable 是 JDK 1.0 时期的产物，对比 HashMap")]),s._v(" "),e("ol",[e("li",[s._v("继承结构不同，Hashtable 继承 Dictionary，HashMap 继承 AbstractMap")]),s._v(" "),e("li",[s._v("Hashtable 不支持 "),e("code",[s._v("null")]),s._v(" 作为 key 和 value")]),s._v(" "),e("li",[s._v("Hashtable 默认大小是 "),e("code",[s._v("11")]),s._v("，扩大逻辑是 "),e("code",[s._v("*2+1")]),s._v("，对于给定大小不会做扩展")]),s._v(" "),e("li",[s._v("Hashtable 索引计算采用除法取余数，更低效")]),s._v(" "),e("li",[s._v("Hashtable 使用链表法作为哈希冲突的解决，没有红黑树优化")]),s._v(" "),e("li",[s._v("Hashtable 是线程安全的")])]),s._v(" "),e("h2",{attrs:{id:"linkedhashmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashmap"}},[s._v("#")]),s._v(" LinkedHashMap")]),s._v(" "),e("ol",[e("li",[e("p",[s._v("继承自 HashMap，基于 HashMap 和 双向链表实现"),e("br"),s._v("\n(1) 基本结点 Entry<K,V> 继承了 HashMap.Node<K,V>，扩展了新字段 before，after"),e("br"),s._v("\n(2) 这也是 LinkedHashMap 设计巧妙的地方，没有额外创建新结点够建链表"),e("br"),s._v("\n(3) 无论结点对象在 HashMap 内部是处于链表还是红黑树结构，都不影响双向链表的结构")])]),s._v(" "),e("li",[e("p",[s._v("默认支持按元素插入顺序访问，也能以设置为按访问顺序访问（accessOrder 设为 true）"),e("br"),s._v("\n(1) 新插入的元素或最近被访问的元素，都将插入双向链表末尾")])]),s._v(" "),e("li",[e("p",[s._v("查找，修改的平均时间复杂度为 "),e("code",[s._v("O(1)")]),e("br"),s._v("\n(1) 因为还需要维护双向链表，因此效率比 HashMap 要低")])]),s._v(" "),e("li",[e("p",[s._v("设计巧妙，很多方法都是在 HashMap 中留的钩子（Hook），实现这些 Hook 就可以实现对应功能了"),e("br"),s._v("\n(1) afterNodeInsertion：put 结尾处触发，用于移除最老的元素（如果需要）"),e("br"),s._v("\n(2) afterNodeAccess：元素被访问时调用，用于移动元素至双向链表末尾（如果需要）"),e("br"),s._v("\n(3) afterNodeRemoval：remove 调用时触发，从双向链表中删除对应结点"),e("br"),s._v("\n(4) newNode：插入新元素时触发，用于创建结点，创建 Entry<K,V> 替换原先的 Node<K,V>")])]),s._v(" "),e("li",[e("p",[s._v("默认不会插入元素时，不会移除旧元素，如果有需要，重写方法 boolean removeEldestEntry()\n(1) afterNodeInsertion 中会根据该方法判断，是否需要移除旧元素，默认返回 false\n(2) 可以利用继承 LinkedHashMap，重写该方法实现 LRU")])])]),s._v(" "),e("h2",{attrs:{id:"treemap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#treemap"}},[s._v("#")]),s._v(" TreeMap")]),s._v(" "),e("p",[s._v("排序 -> 按照 key 排序")]),s._v(" "),e("ol",[e("li",[s._v("key 要实现 Comparable 接口")])]),s._v(" "),e("p",[s._v("key 不能为 null")]),s._v(" "),e("hr"),s._v(" "),e("p",[e("strong",[s._v("参考链接")])]),s._v(" "),e("p",[s._v("[1] "),e("a",{attrs:{href:"https://www.cnblogs.com/tong-yuan/p/10638912.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("彤哥读源码 | HashMap"),e("OutboundLink")],1),e("br"),s._v("\n[1] "),e("a",{attrs:{href:"https://www.cnblogs.com/tong-yuan/p/10639263.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("彤哥读源码 | LinkedHashMap"),e("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=n.exports}}]);