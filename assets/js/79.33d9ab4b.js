(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{369:function(a,s,t){"use strict";t.r(s);var e=t(25),n=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("ul",[t("li",[a._v("HashMap：基于"),t("strong",[a._v("数组")]),a._v("，"),t("strong",[a._v("单链表")]),a._v("，"),t("strong",[a._v("红黑树")]),a._v("，无序，线程不安全")]),a._v(" "),t("li",[a._v("LinkedHashMap：基于")]),a._v(" "),t("li",[a._v("TreeMap")]),a._v(" "),t("li",[a._v("ConcurrentHashMap")]),a._v(" "),t("li",[a._v("Hashtable：基于数组，链表实现，无序，线程安全")])]),a._v(" "),t("p",[a._v("AbstractMap AbstractList 有什么用？")]),a._v(" "),t("h2",{attrs:{id:"hashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[a._v("#")]),a._v(" HashMap")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("基于数组，链表，红黑树实现，数组的元素称为桶")])]),a._v(" "),t("li",[t("p",[a._v("默认初始容量 "),t("code",[a._v("16")]),a._v("，装载因子 "),t("code",[a._v("0.75")]),a._v("，容量总是保持 "),t("code",[a._v("2^n")]),a._v("（方便按位与操作取模）"),t("br"),a._v("\n(1) 如传入容量参数 k，默认向上拓展至 k 最近的 "),t("code",[a._v("2^n")]),a._v(" 作为容量"),t("br"),a._v("\n(2) 懒加载：HashMap 被首次使用时，才进行初始化开辟空间")])]),a._v(" "),t("li",[t("p",[a._v("key 比较：先通过 hashCode() 找到对应的桶，如相同再比较 equals()"),t("br"),a._v("\n(1) 因此自定义类要注意同时重写两个方法"),t("br"),a._v("\n(2) "),t("code",[a._v("null")]),a._v(" 可以作为 key 和 value 使用")])]),a._v(" "),t("li",[t("p",[a._v("查找，修改的平均时间复杂度为 "),t("code",[a._v("O(1)")]),t("br"),a._v("\n(1) 数组查询效率 "),t("code",[a._v("O(1)")]),a._v("，链表查询效率 "),t("code",[a._v("O(k)")]),a._v("，红黑树查询效率 "),t("code",[a._v("O(logk)")]),a._v("，k 为桶中元素个数")])]),a._v(" "),t("li",[t("p",[a._v("插入操作 put()：通过 hash(key) 方法得到 hash 值，再由 hash 值计算索引"),t("br"),a._v("\n(1) 哈希值：由 key 的 hashCode 计算，高 16 位不变，低 16 位与高 16 位做一次异或运算，这样通过按位与取模时，高 16 位也能参与散列"),t("br"),a._v("\n(2) 索引：采用高效的按位与操作，index = (n - 1) & hash()，n 是容量")])]),a._v(" "),t("li",[t("p",[a._v("扩容操作 resize()：每次扩容为原来 "),t("code",[a._v("2 倍")]),t("br"),a._v("\n(1) 由取模算法可知，扩容后元素的桶位置只有两种可能：原位置 or 原位置 + oldCap"),t("br"),a._v("\n(2) 此时会对桶中的链表或红黑树进行拆分，分成以上两类")])]),a._v(" "),t("li",[t("p",[a._v("树化操作 treeifyBin()：发生在插入新元素时，当单个桶中元素数量 "),t("code",[a._v(">= 8")]),a._v(" 时发生"),t("br"),a._v("\n(1) 若此时，桶的数量 "),t("code",[a._v("< 64")]),a._v(" ，扩容代替树化操作"),t("br"),a._v("\n(2) 若此时，桶的数量 "),t("code",[a._v(">= 64")]),a._v("，树化操作进行"),t("br"),a._v("\n(3) 链表过长时，查找效率低下，可以利用红黑树快速增删改查的特点提高性能"),t("br"),a._v("\n(4) 但是当红黑树中结点太少时，红黑树要维持平衡，比起链表，性能优势并不明显"),t("br"),a._v("\n(5) 因此当桶数量 "),t("code",[a._v("< 64")]),a._v("，即容量较小时，哈希碰撞的几率会比较大，此时应优先扩容")])]),a._v(" "),t("li",[t("p",[a._v("反树化操作 untreeify()：当 resize() 拆分红黑树时，拆分后，若发现单个桶中元素数量 "),t("code",[a._v("<= 6")]),a._v("，进行反树化")])])]),a._v(" "),t("details",[t("summary",[a._v("定义")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// since JDK 1.2")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HashMap")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("​"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("AbstractMap")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("​"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Map")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("​"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Cloneable")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Serializable")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])])]),a._v(" "),t("h2",{attrs:{id:"hashtable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashtable"}},[a._v("#")]),a._v(" Hashtable")]),a._v(" "),t("p",[a._v("Hashtable 是 JDK 1.0 时期的产物，对比 HashMap")]),a._v(" "),t("ol",[t("li",[a._v("继承结构不同，Hashtable 继承 Dictionary，HashMap 继承 AbstractMap")]),a._v(" "),t("li",[a._v("Hashtable 不支持 "),t("code",[a._v("null")]),a._v(" 作为 key 和 value")]),a._v(" "),t("li",[a._v("Hashtable 默认大小是 "),t("code",[a._v("11")]),a._v("，扩大逻辑是 "),t("code",[a._v("*2+1")]),a._v("，对于给定大小不会做扩展")]),a._v(" "),t("li",[a._v("Hashtable 索引计算采用除法取余数，更低效")]),a._v(" "),t("li",[a._v("Hashtable 使用链表法作为哈希冲突的解决，没有红黑树优化")]),a._v(" "),t("li",[a._v("Hashtable 是线程安全的")])]),a._v(" "),t("details",[t("summary",[a._v("定义")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// since JDK 1.0")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Hashtable")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("​"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Dictionary")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("​"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Map")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("​"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Cloneable")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Serializable")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])])]),a._v(" "),t("h2",{attrs:{id:"linkedhashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashmap"}},[a._v("#")]),a._v(" LinkedHashMap")]),a._v(" "),t("p",[a._v("有序 -> 按照插入顺序")]),a._v(" "),t("h2",{attrs:{id:"treemap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#treemap"}},[a._v("#")]),a._v(" TreeMap")]),a._v(" "),t("p",[a._v("排序 -> 按照 key 排序")]),a._v(" "),t("ol",[t("li",[a._v("key 要实现 Comparable 接口")])]),a._v(" "),t("p",[a._v("key 不能为 null")]),a._v(" "),t("hr"),a._v(" "),t("p",[t("strong",[a._v("参考链接")])]),a._v(" "),t("p",[a._v("[1] "),t("a",{attrs:{href:"https://www.cnblogs.com/tong-yuan/p/10638912.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("彤哥读源码 | HashMap"),t("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=n.exports}}]);