(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{409:function(t,e,a){"use strict";a.r(e);var v=a(25),r=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"jmm-基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jmm-基本概念"}},[t._v("#")]),t._v(" JMM 基本概念")]),t._v(" "),a("p",[t._v("Java 内存模型（JMM）主要就是围绕解决可见性、原子性、有序性问题建立的")]),t._v(" "),a("p",[t._v("解决可见性和有序性问题，最简单的方法就是"),a("strong",[t._v("禁用缓存")]),t._v("和"),a("strong",[t._v("编译器优化")]),t._v("，但是这将极大影响程序的性能")]),t._v(" "),a("p",[t._v("JMM 总的来说是一种复杂的规范，从不同视角有不同的定义：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("语言视角")]),t._v("：定义了 Java 自己的内存模型，屏蔽掉各种硬件和操作系统的内存访问差异，保证 Java 程序在各个平台下都能达到一致的内存访问效果（不同于 C，直接使用底层硬件的内存模型）")]),t._v(" "),a("li",[a("strong",[t._v("开发视角")]),t._v("：规范了 JVM 如何提供一些方法，去按需禁用缓存和编译优化，以及解决原子性问题，这些方法包括一些关键字：final、volatile、synchronized，以及 happen - before 规则")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("JMM 和 JVM 内存模型")]),t._v(" "),a("p",[t._v("两者都是一种规范，属于不同层次的划分：")]),t._v(" "),a("ul",[a("li",[t._v("JMM 描述多线程运行时的内存间交互，为了程序可以正确并发执行")]),t._v(" "),a("li",[t._v("JVM 内存模型描述 JVM 的内存如何划分，为了便于理解和管理 Java 程序内存")])])]),t._v(" "),a("h2",{attrs:{id:"jmm-具体内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jmm-具体内容"}},[t._v("#")]),t._v(" JMM 具体内容")]),t._v(" "),a("div",{attrs:{align:"center"}},[a("img",{staticStyle:{zoom:"70%"},attrs:{src:"/img/Java/JMM.png"}})]),t._v(" "),a("p",[t._v("JMM 规定所有的共享变量都存储在"),a("strong",[t._v("主内存")]),t._v("（Main Memory），此处主内存可以类比硬件的主内存，但是实际上仅仅是 JVM 内存的一部分")]),t._v(" "),a("p",[t._v("每个线程拥有自己的"),a("strong",[t._v("工作内存")]),t._v("（Working Memory），工作内存中保存了被该线程使用到的变量的主内存副本拷贝，工作内存也属于抽象概念，涵盖了缓存，寄存器等")]),t._v(" "),a("p",[t._v("线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量")]),t._v(" "),a("h3",{attrs:{id:"内存间交互"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存间交互"}},[t._v("#")]),t._v(" 内存间交互")]),t._v(" "),a("div",{attrs:{align:"center"}},[a("img",{staticStyle:{zoom:"80%"},attrs:{src:"/img/Java/JMMAtom.png"}})]),t._v(" "),a("p",[t._v("关于主内存与工作内存交互，JMM 定义了 8 种基本操作，虚拟机实现时必须保证每种操作都是"),a("strong",[t._v("原子的")]),t._v("，即不可再分的（对于 double/long 变量，load/sotre，read/write 操作在某些平台上允许有例外）：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("操作")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("作用")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("lock（锁定）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("将主内存变量加锁，标识为线程独占状态")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("unlock（解锁）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("将主内存变量解锁，解锁后可被其他线程锁定")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("read（读取）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("从主内存读取变量的值，传输到工作内存中，准备 load")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("load（载入）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("将变量的值写入工作内存")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("use（使用）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("从工作内存读取数据来进行计算")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("assign（赋值）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("将运算后的值重写存储到工作内存中")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("store（存储）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("从工作内存读取变量的值，传输到主内存，准备 write")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("write（写入）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("将变量的值写入主内存")])])])]),t._v(" "),a("h2",{attrs:{id:"happen-before-规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#happen-before-规则"}},[t._v("#")]),t._v(" Happen - before 规则")]),t._v(" "),a("p",[t._v("Happend - before 规则是 Java 1.5 版本对 volatile 语义的增强，进一步解决可见性和有序性问题")]),t._v(" "),a("p",[t._v("Happen - before 实际上是描述 2 个操作之间的"),a("strong",[t._v("内存可见性")]),t._v("：如果操作 A happen - before 操作 B，那么 A 的结果对 B 可见")]),t._v(" "),a("p",[t._v("Happen - before 规则约束了编译器优化，主要有以下规则：")]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("程序顺序性规则")]),t._v("，一个线程内，按照代码顺序，书写在前面的操作 happens-before 书写在后面的操作")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("volatile 变量规则")]),t._v("，对一个 volatile 变量的写操作 happens-before 后续对这个变量的读操作")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("传递规则")]),t._v("，如果操作 A happens-before 操作 B，而操作 B 又 happens-before 操作 C，则可以得出操作 A happens-before 操作 C")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("锁定规则")]),t._v("，一个 unLock 操作 happens-before 后面对同一个锁的 lock 操作")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("线程 start() 规则")]),t._v("，A 线程启动子线程 B，则在 B 能看到 A 在调用 B.start() 之前的所有操作，且 B.start() happens-before 线程 B 中的任意操作")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("线程 join() 规则")]),t._v("，A 线程调用 B.join()，B 线程结束后，A 线程能看到 B 线程所有操作")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("线程 interrupt() 规则")]),t._v("，对线程 interrupt() 方法的调用 happens-before 被中断线程的代码检测到中断事件的发生")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("对象终结规则")]),t._v("，一个对象的初始化完成 happens-before 它的 finalize() 方法的开始")])])]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("参考：")]),t._v(" "),a("p",[t._v("[1] "),a("a",{attrs:{href:"https://mp.weixin.qq.com/s/SvxHhkGu84rFXaWbeiAXQg",target:"_blank",rel:"noopener noreferrer"}},[t._v("陈彩华 51CTO技术栈 | Java内存模型原理，你真的理解吗？"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("[2] "),a("a",{attrs:{href:"http://ddrv.cn/a/35646",target:"_blank",rel:"noopener noreferrer"}},[t._v("算法网 | JVM（十一）Java 内存模型"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("[3] "),a("a",{attrs:{href:"https://time.geekbang.org/column/article/84017",target:"_blank",rel:"noopener noreferrer"}},[t._v("极客时间 | Java 并发编程实战"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);