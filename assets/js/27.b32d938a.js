(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{486:function(v,_,t){"use strict";t.r(_);var s=t(25),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"算法步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法步骤"}},[v._v("#")]),v._v(" 算法步骤")]),v._v(" "),t("p",[t("strong",[v._v("核心思想")]),v._v("：分而治之，将原问题分解为 n 个规模更小的，但是结构与原问题类似的子问题，递归解决子问题，再合并得到结果")]),v._v(" "),t("p",[t("strong",[v._v("基本步骤")]),v._v("：")]),v._v(" "),t("ol",[t("li",[v._v("分解：原问题分解为若干子问题")]),v._v(" "),t("li",[v._v("解决：对子问题进行递归求解或根据终止条件（Base Case）求解")]),v._v(" "),t("li",[v._v("合并：将子问题的结果合并，得到原问题的解")])]),v._v(" "),t("p",[t("strong",[v._v("适用条件")]),v._v("：")]),v._v(" "),t("ol",[t("li",[v._v("原问题可以分解为具有相同结构的子问题")]),v._v(" "),t("li",[v._v("子问题可以独立求解，互相没有关联（分治与动态规划的明显区别）")]),v._v(" "),t("li",[v._v("具有分解的终止条件（Base Case）")]),v._v(" "),t("li",[v._v("子问题结果的合并，复杂度不能太高，否则算法不能有效降低复杂度")])]),v._v(" "),t("h2",{attrs:{id:"典型问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#典型问题"}},[v._v("#")]),v._v(" 典型问题")]),v._v(" "),t("ol",[t("li",[v._v("二维平面上有 n 个点，如何快速计算出两个距离最近的点对")]),v._v(" "),t("li",[v._v("有两个 n"),t("em",[v._v("n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A")]),v._v("B")])]),v._v(" "),t("p",[t("strong",[v._v("海量数据处理")]),v._v("：大部分数据结构和算法都是基于内存存储和单机处理，因此如果数据量非常大，无法一次加载到内存中去，很多算法便无法使用。一种解决思路是利用分治算法，将数据分为若干内存可以容纳的较小部分，对每个部分单独进行处理，最终再合并结果。这样不仅能克服内存限制，还能进一步利用多线程或者多机处理，加快处理速度")])])}),[],!1,null,null,null);_.default=a.exports}}]);