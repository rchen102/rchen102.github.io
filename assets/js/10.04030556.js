(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{212:function(t,a,s){"use strict";s.r(a);var r=s(0),_=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"队列的特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#队列的特性"}},[t._v("#")]),t._v(" 队列的特性")]),t._v(" "),s("h3",{attrs:{id:"_1-操作受限的线性表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-操作受限的线性表"}},[t._v("#")]),t._v(" 1. 操作受限的线性表")]),t._v(" "),s("ul",[s("li",[t._v("先进先出(First in, first out)")])]),t._v(" "),s("h3",{attrs:{id:"_2-两个基本操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-两个基本操作"}},[t._v("#")]),t._v(" 2. 两个基本操作")]),t._v(" "),s("ul",[s("li",[t._v("入队(enqueue)")]),t._v(" "),s("li",[t._v("出队(dequeue)")])]),t._v(" "),s("h2",{attrs:{id:"队列的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#队列的实现"}},[t._v("#")]),t._v(" 队列的实现")]),t._v(" "),s("p",[t._v("相比栈，队列需要两个指针，分别指向队首和队尾(head, tail)")]),t._v(" "),s("ul",[s("li",[t._v("顺序队列(使用数组实现)\n"),s("ul",[s("li",[t._v("对于数组实现，在不断的入队出队操作中，头尾指针都将持续向后移动")]),t._v(" "),s("li",[t._v("解决放案1: 数据搬迁，在进行入队操作时，如果没有空闲空间，则触发数据搬迁")]),t._v(" "),s("li",[t._v("解决放案2: 循环链表，避免了数据搬迁，更加高效")])])]),t._v(" "),s("li",[t._v("链式队列(使用链表实现)")])]),t._v(" "),s("h2",{attrs:{id:"其他队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其他队列"}},[t._v("#")]),t._v(" 其他队列")]),t._v(" "),s("h3",{attrs:{id:"阻塞队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#阻塞队列"}},[t._v("#")]),t._v(" 阻塞队列")]),t._v(" "),s("ul",[s("li",[t._v("队列为空时，出队操作会被阻塞，直到队列中有了数据再返回数据")]),t._v(" "),s("li",[t._v("队列已满时，入队操作会被阻塞，直到队列中有了空闲位置再插入数据")])]),t._v(" "),s("h3",{attrs:{id:"并发队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发队列"}},[t._v("#")]),t._v(" 并发队列")]),t._v(" "),s("ul",[s("li",[t._v("线程安全的队列")])])])}),[],!1,null,null,null);a.default=_.exports}}]);