(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{427:function(t,v,a){"use strict";a.r(v);var _=a(25),r=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),a("p",[t._v("首先需要注意，「内存结构」和「内存模型（JMM）」是两个不同的概念")]),t._v(" "),a("p",[t._v("JVM 内存结构分成了许多区域，如堆，方法区，虚拟机栈等等，需要注意，这些都是虚拟存在的，便于管理和理解 Java 程序内存")]),t._v(" "),a("p",[t._v("JVM 本身就是一个虚拟的机器，本质就是运行在系统上的一个 JVM 进程，在运行 Java 程序的时候，会将这些区域尽可能分配在硬件的寄存器或缓存上，以达到更高的速度")]),t._v(" "),a("div",{attrs:{align:"center"}},[a("p",[a("img",{attrs:{src:"/img/Java/JVM%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84.jpg",alt:"JVM内存映射"}})])]),t._v(" "),a("h2",{attrs:{id:"内存结构详解（jdk1-8-以前）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存结构详解（jdk1-8-以前）"}},[t._v("#")]),t._v(" 内存结构详解（JDK1.8 以前）")]),t._v(" "),a("p",[t._v("JVM 执行程序的过程：Java 源码会被编译为字节码文件，然后由 JVM 中的类加载器加载，加载完毕后，交由 JVM 执行引擎执行")]),t._v(" "),a("p",[t._v("整个执行期间，JVM 会用一段空间来管理需要用到的数据和相关信息，这个空间被称为运行时数据区，也即 JVM 内存，本地接口则提供了 Java 与 OS 本地代码互相调用的功能")]),t._v(" "),a("div",{attrs:{align:"center"}},[a("img",{staticStyle:{zoom:"40%"},attrs:{src:"/img/Java/JVM内存结构1.jpg"}})]),t._v(" "),a("ul",[a("li",[t._v("JVM 内存结构总共分为五个区：虚拟机栈、本地方法栈、程序计数器、方法区、堆")]),t._v(" "),a("li",[t._v("其中"),a("strong",[t._v("黄色")]),t._v("标记区域为线程"),a("strong",[t._v("私有")]),t._v("，"),a("strong",[t._v("绿色")]),t._v("区域为线程"),a("strong",[t._v("共享")])]),t._v(" "),a("li",[t._v("不同区域占据大小不同，一般堆最大，程序计数器最小")])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"堆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[t._v("#")]),t._v(" 堆")]),t._v(" "),a("p",[t._v("Java 堆被所有线程共享，在 JVM 启动时创建，主要用来存储对象实例本身和数组")]),t._v(" "),a("p",[t._v("堆是 JVM 管理的内存中最大的一块，也是 GC 发生的主要区域，因此也被称为 GC 堆")]),t._v(" "),a("div",{attrs:{align:"center"}},[a("img",{staticStyle:{zoom:"65%"},attrs:{src:"/img/Java/Heap.png"}})]),t._v(" "),a("ul",[a("li",[t._v("Java 堆的 GC 采用分代收集算法")]),t._v(" "),a("li",[t._v("主要分为新生代和老年代，新生代还可以细分为：Eden 空间，S0 空间，S1 空间")]),t._v(" "),a("li",[t._v("Java 堆可以处于物理空间不连续，只要逻辑上连续即可，因此空间不足时，可以扩展")]),t._v(" "),a("li",[t._v("当堆中没有内存完成分配，堆本身也无法扩展时，会抛出 OutOfMemoryError")])]),t._v(" "),a("h3",{attrs:{id:"方法区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[t._v("#")]),t._v(" 方法区")]),t._v(" "),a("p",[t._v("根据 JVM 规范，方法区被所有线程共享，主要存储的就是类的模板（堆存储类的实例）：已被 JVM 加载的类字节码、class/method/field 等元数据对象、static-final 常量、static 变量、即时编译（JIT）后的代码等数据")]),t._v(" "),a("p",[t._v("JVM 规范中，方法区在 JVM 启动时创建，虽然方法区是堆的逻辑组成部分，但是别名是 non-heap，因此不要求在方法区实现 GC")]),t._v(" "),a("p",[t._v("JVM 规范只规定了有方法区这个概念和其作用，并没有规定如何去实现它，不同 JVM 有不同的实现方式")]),t._v(" "),a("p",[a("strong",[t._v("不同版本 HotSpot JVM 方法区")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("JDK 1.7 前：采用"),a("strong",[t._v("永久代")]),t._v("实现，把 GC 分代收集扩展至了方法区，运行时常量池（包含字符串常量池）也属于方法区")]),t._v(" "),a("li",[t._v("JDK 1.7 及以后：字符串常量池和 Class 实例，从永久代移动到 Java 堆内存")]),t._v(" "),a("li",[t._v("JDK 1.8 及以后：采用"),a("strong",[t._v("元空间")]),t._v("实现方法区，变化如下：\n"),a("ul",[a("li",[t._v("存储位置不同，元空间使用本地内存，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的 OutOfMemoryError")]),t._v(" "),a("li",[t._v("存储内容不同：元空间只存储类的元信息，static 变量和常量池等并入堆中")])])])]),t._v(" "),a("div",{attrs:{align:"center"}},[a("p",[a("img",{attrs:{src:"/img/Java/MethodArea.png",alt:"JVM内存映射"}})])]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("参考：")]),t._v(" "),a("p",[t._v("[1] "),a("a",{attrs:{href:"https://blog.csdn.net/Searchin_R/article/details/84972579",target:"_blank",rel:"noopener noreferrer"}},[t._v("JVM——内存模型（三）：堆与方法区"),a("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=r.exports}}]);