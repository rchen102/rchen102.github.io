(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{478:function(v,_,t){"use strict";t.r(_);var s=t(25),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[v._v("#")]),v._v(" 介绍")]),v._v(" "),t("p",[v._v("动态规划是运筹学的一个分支，用于求解一个"),t("strong",[v._v("多阶段决策")]),v._v("问题的"),t("strong",[v._v("最优解")]),v._v("，适用于动态规划求解的问题，满足以下要求：")]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("状态无后效性")]),v._v("：某个阶段状态给定后，则该阶段以后过程的发展不受该阶段以前各阶段状态的影响")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("最优性原理")]),v._v("：问题的一个最优决策序列的子序列也是最优的（通常利用“剪切”，来反证）")])])]),v._v(" "),t("p",[v._v("简单来说，就是一个问题需要满足：")]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("重叠子问题")]),v._v("：即可以被划分成规模更小的子问题")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("最优子问题")]),v._v("：问题的最优解是由其子问题的最优解来构造的，且子问题间必须互相独立")])])]),v._v(" "),t("p",[v._v("动态规划的思想实质是"),t("strong",[v._v("分治思想")]),v._v("和"),t("strong",[v._v("解决冗余")])]),v._v(" "),t("p",[v._v("对比贪心算法：")]),v._v(" "),t("ul",[t("li",[v._v("动态规划：利用问题的最优子结构，自底向上从子问题的最优解逐步构造整个问题的最优解")]),v._v(" "),t("li",[v._v("贪心算法：虽然也利用问题的最优子结构，但是是以自顶向下的方式，先做选择再求解一个选出的子问题")])]),v._v(" "),t("h2",{attrs:{id:"回溯算法、贪心算法、动态规划比较"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回溯算法、贪心算法、动态规划比较"}},[v._v("#")]),v._v(" 回溯算法、贪心算法、动态规划比较")]),v._v(" "),t("ul",[t("li",[v._v("贪心算法：一条路走到黑，就一次机会，只能哪边看着顺眼走哪边")]),v._v(" "),t("li",[v._v("回溯算法：一条路走到黑，无数次重来的机会，还怕我走不出来 (Snapshot View)")]),v._v(" "),t("li",[v._v("动态规划：拥有上帝视角，手握无数平行宇宙的历史存档， 同时发展出无数个未来 (Versioned Archive View)")])])])}),[],!1,null,null,null);_.default=r.exports}}]);