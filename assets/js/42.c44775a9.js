(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{419:function(v,_,t){"use strict";t.r(_);var s=t(25),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[v._v("#")]),v._v(" 介绍")]),v._v(" "),t("p",[t("strong",[v._v("常见属性")])]),v._v(" "),t("ul",[t("li",[v._v("节点的高度：节点到叶子节点的最长路径")]),v._v(" "),t("li",[v._v("节点的深度：根节点到该节点的路径")]),v._v(" "),t("li",[v._v("节点的层数：节点的深度 + 1")]),v._v(" "),t("li",[v._v("树的高度：根节点的高度")])]),v._v(" "),t("p",[t("strong",[v._v("常见二叉树")])]),v._v(" "),t("ul",[t("li",[v._v("满二叉树：除叶子节点外，每个节点都有左右子树")]),v._v(" "),t("li",[v._v("完全二叉树：叶子节点只出现在最下面两层，且最后一层叶子节点都紧密靠左排列，除了最后一层，其他层节点个数达到最大")]),v._v(" "),t("li",[v._v("二叉搜索树：任意一个节点，左子树中的每个节点都小于该节点，右子树的每个节点都大于该节点，且左右子树也是二叉搜索树")])]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),t("p",[v._v("判断二叉搜索树时，不能仅仅判断左右子节点是否满足「左小右大」，一定要注意是整个左子树和整个右子树")])]),v._v(" "),t("h2",{attrs:{id:"实现方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现方法"}},[v._v("#")]),v._v(" 实现方法")]),v._v(" "),t("ul",[t("li",[v._v("基于链表的"),t("strong",[v._v("链式储存")])]),v._v(" "),t("li",[v._v("基于数组的"),t("strong",[v._v("顺序存储")])])]),v._v(" "),t("p",[v._v("对于顺序存储，根节点存储在下标 "),t("code",[v._v("i=1")]),v._v(" 的位置，对于任意节点 "),t("code",[v._v("i")]),v._v("，其左节点为 "),t("code",[v._v("2i")]),v._v("，右节点为 "),t("code",[v._v("2i+1")]),v._v("，父节点为 "),t("code",[v._v("i/2")]),v._v(" 。完全二叉树天然适合于顺序存储，除了下标为 0 的位置，能够充分利用所有的内存空间")]),v._v(" "),t("h2",{attrs:{id:"复杂度分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#复杂度分析"}},[v._v("#")]),v._v(" 复杂度分析")]),v._v(" "),t("p",[v._v("对于二叉搜索树来说，操作的时间复杂度取决于树的高度，即与二叉树的形状有关")]),v._v(" "),t("ul",[t("li",[v._v("当二叉树在比较平衡的状态下，查找、插入、删除都只需要 O(logn) 时间")]),v._v(" "),t("li",[v._v("极度不平衡的情况下，时间复杂度则会退化为 O(n)")])]),v._v(" "),t("h2",{attrs:{id:"对比散列表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对比散列表"}},[v._v("#")]),v._v(" 对比散列表")]),v._v(" "),t("ul",[t("li",[v._v("散列表中的数据是无序的，二叉树只需 O(n) 时间就可以输出有序数组（中序）")]),v._v(" "),t("li",[v._v("散列表性能不稳定（散列冲突的存在），平衡二叉树性能非常稳定")]),v._v(" "),t("li",[v._v("散列的构造更复杂，需要考虑散列函数、散列冲突、扩容方法等，二叉树只需要考虑平衡性")]),v._v(" "),t("li",[v._v("散列表装载因子不能太高，二叉树更能充分利用空间")])])])}),[],!1,null,null,null);_.default=a.exports}}]);