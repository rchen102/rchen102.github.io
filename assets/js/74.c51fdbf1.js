(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{376:function(t,a,s){"use strict";s.r(a);var e=s(25),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"内存模型背景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存模型背景"}},[t._v("#")]),t._v(" 内存模型背景")]),t._v(" "),s("h3",{attrs:{id:"物理机并发问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#物理机并发问题"}},[t._v("#")]),t._v(" 物理机并发问题")]),t._v(" "),s("div",{attrs:{align:"center"}},[s("img",{staticStyle:{zoom:"70%"},attrs:{src:"/img/Java/JMMCPU.png"}})]),t._v(" "),s("p",[s("strong",[t._v("1. 缓存一致性问题")])]),t._v(" "),s("p",[t._v("CPU 运行速度与内存读写速度有数量级的差距，因此 CPU 增加了一级高速缓存，以均衡与内存的速度差异，CPU 运行时，将需要用到的数据复制到缓存中，计算结束后，再从缓存中同步回主内存")]),t._v(" "),s("p",[t._v("多核环境下，每个 CPU 内核都拥有自己的高速缓存，当多线程涉及同一内存区域（共享变量），可能导致各自的缓存数据不一致，为此，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，来维护缓存的一致性，比如 MESI 协议")]),t._v(" "),s("p",[s("strong",[t._v("2. 重排序优化问题")])]),t._v(" "),s("p",[t._v("为了充分利用 CPU 内部运算单元和 CPU 高速缓存，提高运行速度，编译器和处理器常常会对指令进行重排序：")]),t._v(" "),s("div",{attrs:{align:"center"}},[s("img",{staticStyle:{zoom:"100%"},attrs:{src:"/img/Java/Reorder.png"}})]),t._v(" "),s("ul",[s("li",[t._v("编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序")]),t._v(" "),s("li",[t._v("指令级并行的重排序：现代 CPU 采用指令级并行技术，如果不存在数据依赖，可以多条指令重叠执行")]),t._v(" "),s("li",[t._v("内存系统的重排序：由于 CPU 使用缓存和读/写缓冲区，使得 load/store 操作看上去可能是在乱序执行")])]),t._v(" "),s("p",[t._v("单核环境下，重排序是提高 CPU 运算速度的一种优化，可以保证运算结果与顺序执行相同")]),t._v(" "),s("p",[t._v("多核环境下，如果一个线程的计算任务依赖另一个线程计算任务的中间结果，且对相关数据读写没有任何防护措施，则代码的顺序性无法保证执行的顺序性，最终的结果也会不同于逻辑结果")]),t._v(" "),s("details",[s("summary",[t._v("代码样例")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * 两个线程，一个执行 writer，一个执行 reader\n * 正常情况：A 执行完成后，才会执行 D\n * 重排序后：A 和 B 无依赖关系，因此 B 可能先于 A 执行，导致 D 也先于 A 执行\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReorderDemo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" counter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" flag "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("writer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        counter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1")]),t._v("\n        flag "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("reader")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("flag"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("counter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//4")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br")])])]),t._v(" "),s("h2",{attrs:{id:"java-内存模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-内存模型"}},[t._v("#")]),t._v(" Java 内存模型")]),t._v(" "),s("h3",{attrs:{id:"jmm-基本概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jmm-基本概念"}},[t._v("#")]),t._v(" JMM 基本概念")]),t._v(" "),s("p",[t._v("内存模型就是为了解决上述问题而提出的，是对内存和高速缓存读写访问的过程的抽象，不同系统和平台可能有不同的内存模型")]),t._v(" "),s("p",[t._v("JVM 规范中试图定义一种 Java 内存模型（JMM），来屏蔽掉各种硬件和操作系统的内存访问差异，保证 Java 程序在各个平台下都能达到一致的内存访问效果，不同于 C++，直接使用操作系统平台内存模型，导致同一代码在不同平台运行，可能存在并发问题")]),t._v(" "),s("p",[t._v("Java 内存模型和 JVM 内存模型，都是一种规范，属于不同层次的划分：Java 内存模型描述多线程运行时的内存间交互，为了程序可以正确并发执行；JVM 内存模型描述 JVM 的内存划分，为了便于管理和理解 Java 程序内存")]),t._v(" "),s("p",[t._v("更具体的说，JMM 主要是为了定义了程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节")]),t._v(" "),s("p",[t._v("此处的变量与 Java 编程中所说的变量有所区别，包括了实例字段、静态字段和构成数值对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的")]),t._v(" "),s("p",[t._v("总结：JMM（和其定义的一系列规则），通过数据同步协议，保证内存副本之间的数据一致性，同时防止重排序对程序的影响")]),t._v(" "),s("h3",{attrs:{id:"jmm-具体组成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jmm-具体组成"}},[t._v("#")]),t._v(" JMM 具体组成")]),t._v(" "),s("div",{attrs:{align:"center"}},[s("img",{staticStyle:{zoom:"70%"},attrs:{src:"/img/Java/JMM.png"}})]),t._v(" "),s("p",[s("strong",[t._v("1. 主内存")])]),t._v(" "),s("p",[t._v("JMM 规定所有的变量都存储在共同的主内存（Main Memory）中")]),t._v(" "),s("p",[t._v("此处主内存可以类比硬件的主内存，但是实际上仅仅是 JVM 内存的一部分")]),t._v(" "),s("p",[s("strong",[t._v("2. 工作内存")])]),t._v(" "),s("p",[t._v("每个线程拥有自己的工作内存（Working Memory），工作内存中保存了被该线程使用到的变量的主内存副本拷贝")]),t._v(" "),s("p",[t._v("线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量")]),t._v(" "),s("p",[t._v("工作内存也属于抽象概念，涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化")]),t._v(" "),s("h3",{attrs:{id:"jmm-并发问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jmm-并发问题"}},[t._v("#")]),t._v(" JMM 并发问题")]),t._v(" "),s("p",[s("strong",[t._v("1. 数据一致性问题")])]),t._v(" "),s("p",[t._v("不同线程都拥有自己的工作内存，当多个线程的运算任务涉及同一共享变量时，各自的工作内存内共享变量的副本可能不一致，同步回主内存时，会出现问题")]),t._v(" "),s("p",[t._v("JMM 主要通过一系列的数据同步协议、规则来保证数据的一致性")]),t._v(" "),s("p",[s("strong",[t._v("2. 重排序优化问题")])]),t._v(" "),s("p",[t._v("Java 中重排序，主要分为两类，分别对应编译时和运行时，即"),s("strong",[t._v("编译期重排序")]),t._v("和"),s("strong",[t._v("运行期重排序")]),t._v("，重排序满足以下两个条件：")]),t._v(" "),s("ul",[s("li",[t._v("遵守 as - if - serial 语义，即单线程环境下，重排序后的运行结果与顺序执行是相同的")]),t._v(" "),s("li",[t._v("不对存在数据依赖关系的指令进行重排序")])]),t._v(" "),s("p",[t._v("尽管满足这两个条件，多线程环境下，如果线程间处理逻辑存在依赖关系，有可能因为指令重排序导致运行结果与预期不同")]),t._v(" "),s("h2",{attrs:{id:"java-内存间交互"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-内存间交互"}},[t._v("#")]),t._v(" Java 内存间交互")]),t._v(" "),s("div",{attrs:{align:"center"}},[s("img",{staticStyle:{zoom:"80%"},attrs:{src:"/img/Java/JMMAtom.png"}})]),t._v(" "),s("p",[t._v("关于主内存与工作内存交互，JMM 定义了 8 种基本操作，虚拟机实现时必须保证每种操作都是"),s("strong",[t._v("原子的")]),t._v("，即不可再分的（对于 double/long 变量，load/sotre，read/write 操作在某些平台上允许有例外）：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("操作")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("作用")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("lock（锁定）")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("将主内存变量加锁，标识为线程独占状态")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("unlock（解锁）")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("将主内存变量解锁，解锁后可被其他线程锁定")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("read（读取）")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("从主内存读取变量的值，传输到工作内存中，准备 load")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("load（载入）")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("将变量的值写入工作内存")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("use（使用）")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("从工作内存读取数据来进行计算")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("assign（赋值）")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("将运算后的值重写存储到工作内存中")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("store（存储）")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("从工作内存读取变量的值，传输到主内存，准备 write")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("write（写入）")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("将变量的值写入主内存")])])])]),t._v(" "),s("h2",{attrs:{id:"java-内存模型运行规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-内存模型运行规则"}},[t._v("#")]),t._v(" Java 内存模型运行规则")]),t._v(" "),s("h3",{attrs:{id:"三大特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三大特性"}},[t._v("#")]),t._v(" 三大特性")]),t._v(" "),s("p",[t._v("总的来说，JMM 一系列运行规则主要就是围绕原子性、可见性、有序性特征建立的")]),t._v(" "),s("p",[s("strong",[t._v("1. 原子性")]),t._v("（Atomicity）")]),t._v(" "),s("p",[t._v("一个操作或者多个操作，要么全部执行完毕且过程中不会被打断，要么全都不执行")]),t._v(" "),s("p",[t._v("即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰")]),t._v(" "),s("p",[s("strong",[t._v("2. 可见性")]),t._v("（Visibility）")]),t._v(" "),s("p",[t._v("多线程环境下，一个线程修改了共享变量的值，其他线程能够立即看到修改后的值")]),t._v(" "),s("p",[t._v("JMM 通过控制主内存与每个线程本地内存之间的交互，来为各个线程提供共享变量的可见性")]),t._v(" "),s("p",[s("strong",[t._v("3. 有序性")]),t._v("（Ordering）")]),t._v(" "),s("p",[t._v("如果在本线程内观察，所有操作都是有序的，如果在一个线程中观察另一个线程，所有操作都是无序的")]),t._v(" "),s("ul",[s("li",[t._v("线程内：指令表现为按照串行方式（as - if - serial）执行")]),t._v(" "),s("li",[t._v("线程间：观察其他线程并发执行非同步的代码时，由于指令重排序优化，任何代码都可能交叉执行")])]),t._v(" "),s("p",[t._v("Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性")]),t._v(" "),s("h3",{attrs:{id:"happens-before"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#happens-before"}},[t._v("#")]),t._v(" happens - before")]),t._v(" "),s("p",[t._v("happens - before 关系用于描述 2 个操作之间的内存可见性：如果操作 A happens - before 操作 B，那么 A 的结果对 B 可见")]),t._v(" "),s("p",[t._v("对于 JMM 来说，单线程环境下，字节码的顺序天然满足该关系，但是多线程情况下，由于共享变量的同步延迟，则不一定，JMM 实现了以下满足 happens - before 关系的规则：")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("程序次序规则")]),t._v("，一个线程内，按照代码顺序，书写在前面的操作 happens-before 书写在后面的操作")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("锁定规则")]),t._v("，一个 unLock 操作 happens-before 后面对同一个锁的 lock 操作")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("volatile 变量规则")]),t._v("，对一个变量的写操作 happens-before 后面对这个变量的读操作")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("传递规则")]),t._v("，如果操作 A happens-before 操作 B，而操作 B 又 happens-before 操作 C，则可以得出操作 A happens-before 操作 C")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("线程启动规则")]),t._v("，Thread 对象的 start() 方法 happens-before 此线程的每个一个动作")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("线程中断规则")]),t._v("，对线程 interrupt() 方法的调用 happens-before 被中断线程的代码检测到中断事件的发生")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("线程终结规则")]),t._v("，线程中所有的操作都 happens-before 线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("对象终结规则")]),t._v("，一个对象的初始化完成 happens-before 它的 finalize() 方法的开始")])])]),t._v(" "),s("p",[t._v("我感觉就是在use这一步以后，将变量丢到了操作栈以后，你通知过来我的工作内存失效，也不影响我执行引擎继续执行，是不会重读的")]),t._v(" "),s("p",[t._v("重排序")]),t._v(" "),s("p",[t._v("顺序一致性")]),t._v(" "),s("p",[t._v("https://mubu.com/doc/2Q_5ufWdwPk")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("参考：")]),t._v(" "),s("p",[t._v("[1] "),s("a",{attrs:{href:"https://mp.weixin.qq.com/s/SvxHhkGu84rFXaWbeiAXQg",target:"_blank",rel:"noopener noreferrer"}},[t._v("陈彩华 51CTO技术栈 | Java内存模型原理，你真的理解吗？"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("[2] "),s("a",{attrs:{href:"http://ddrv.cn/a/35646",target:"_blank",rel:"noopener noreferrer"}},[t._v("算法网 | JVM（十一）Java 内存模型"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("[3] "),s("a",{attrs:{href:"https://www.choupangxia.com/2019/11/04/interview-jvm-gc-05/",target:"_blank",rel:"noopener noreferrer"}},[t._v("程序新视界 | JAVA内存模型(JMM)详解"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("[4] "),s("a",{attrs:{href:"https://www.cnblogs.com/secbro/p/11804404.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("程序新视界 | Java内存模型相关原则详解"),s("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=n.exports}}]);