(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{363:function(v,_,l){"use strict";l.r(_);var t=l(25),P=Object(t.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h2",{attrs:{id:"介绍"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[v._v("#")]),v._v(" 介绍")]),v._v(" "),l("ul",[l("li",[v._v("UDP 是一种尽可能只提供必要服务的轻量级运输协议，提供最少的服务")]),v._v(" "),l("li",[v._v("UDP 是无连接的，因此在两个进程通信前没有握手过程")]),v._v(" "),l("li",[v._v("UDP 提供不可靠的数据传送服务，即不保证报文一定到达目标进程，也不保证按顺序到达")]),v._v(" "),l("li",[v._v("UDP 不包含拥塞控制机制，因此 UDP 发送端可以用希望的任意速率向网络层注入数据")])]),v._v(" "),l("hr"),v._v(" "),l("p",[l("strong",[v._v("工作方式")]),v._v("：除了复用/分解功能，以及少量的差错检测外，UDP 几乎没有对 IP 增加别的东西")]),v._v(" "),l("ul",[l("li",[v._v("UDP 从应用进程得到数据，附加上用于多路复用/分解的源和目的端口号字段，以及两个其他的小字段，形成报文段后交给网络层")]),v._v(" "),l("li",[v._v("网络层将该报文段封装到一个 IP 数据报中，然后尽力将此报文段交付给接收主机")]),v._v(" "),l("li",[v._v("如果报文段能够抵达接收主机，接收端 UDP 使用目的端口号将报文段中的数据交付给相应的套接字")])]),v._v(" "),l("hr"),v._v(" "),l("p",[l("strong",[v._v("优点")]),v._v("：既然相比 TCP ，UDP 存在诸多问题，为何还要使用 UDP 协议")]),v._v(" "),l("ul",[l("li",[l("em",[v._v("应用层能够更精确控制何时发送数据。")]),v._v(" UDP 不存在拥塞控制，只要应用进程将数据交给 UDP 就会立刻打包发送。适合不希望过分延迟数据发送，且能容忍一些数据丢失的应用")]),v._v(" "),l("li",[l("em",[v._v("无需建立连接。")]),v._v(" 相比 TCP，UDP 无需经过三次握手，不会引入建立连接的时延。（可能是 DNS 使用 UDP 的原因，如果 DNS 运行在 TCP 上，则会慢很多）")]),v._v(" "),l("li",[l("em",[v._v("无连接状态。")]),v._v(" TCP 需要在端系统中维护连接状态，包括接收和发送缓存、拥塞控制参数等。UDP 不必维护连接状态，因此能够支持更多的活跃客户")]),v._v(" "),l("li",[l("em",[v._v("分组首部开销小。")]),v._v(" 每个 TCP 报文段有 20 字节的首部开销，而 UDP 仅有 8 个字节")])]),v._v(" "),l("hr"),v._v(" "),l("p",[l("strong",[v._v("应用")])]),v._v(" "),l("ul",[l("li",[v._v("DNS 查询（DNS 协议）。查询主机如果没有收到响应，则向其他服务器发送查询或通知调用的应用程序")]),v._v(" "),l("li",[v._v("路由选择表的更新（RIP 协议）。因为更新周期性发送，更新的丢失常常可以被最近的更新替代")]),v._v(" "),l("li",[v._v("网络管理（SNMP 协议）。网络管理应用通常必须在该网络处于重压状态时运行，此时可靠、拥塞受控的数据传输无法实现")])]),v._v(" "),l("blockquote",[l("p",[v._v("通过在应用程序自身中建立可靠性机制，使用 UDP 的应用程序，事实上也可以实现可靠数据传输")])])])}),[],!1,null,null,null);_.default=P.exports}}]);