(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{252:function(t,a,s){"use strict";s.r(a);var v=s(0),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),s("p",[t._v("散列表也称哈希表，本质上是利用了数组支持按照下标随机访问的特性。基本元素是由键（Key）和值（Value）组成的键值对，通过散列函数将 Key 映射为下标，将 Value 存储在数组中对应下标的位置")]),t._v(" "),s("h2",{attrs:{id:"散列冲突"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#散列冲突"}},[t._v("#")]),t._v(" 散列冲突")]),t._v(" "),s("p",[t._v("不同 Key 被映射到相同的下标称为散列冲突，通常有以下解决方法")]),t._v(" "),s("h3",{attrs:{id:"开放寻址法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开放寻址法"}},[t._v("#")]),t._v(" 开放寻址法")]),t._v(" "),s("p",[s("strong",[t._v("1. 线性探测")])]),t._v(" "),s("ul",[s("li",[t._v("插入：如果发现位置已被占用，就从当前位置开始，依次向后查找空闲位置")]),t._v(" "),s("li",[t._v("查找：通过 Key 求出散列值后，比较对应元素的 Key 是否与要查找的 Key 相同，如相同则已经找到，如不同则继续向下线性查找，遇到第一个空闲位置时停止（可知元素不存在）")]),t._v(" "),s("li",[t._v("删除：不能仅仅将删除元素置空，因为可能会导致查找出错，可以将删除的元素标记为 deleted")])]),t._v(" "),s("p",[t._v("随着散列表插入元素增多，散列冲突可能性越大，极端情况下可能需要探测整个散列表，因此最差复杂度为 O(n)")]),t._v(" "),s("blockquote",[s("p",[t._v("查找时，是以遇到空闲作为终止条件")]),t._v(" "),s("ul",[s("li",[t._v("给定 A 和 B 都映射到下标 X 上，A 先插入散列表，则 A 占据位置 X")]),t._v(" "),s("li",[t._v("B 接着插入散列表，占据位置 X + 1")]),t._v(" "),s("li",[t._v("删除 A，将 X 置空")]),t._v(" "),s("li",[t._v("此时如果查找 B，则会误判 B 不存在")])])]),t._v(" "),s("p",[s("strong",[t._v("2. 二次探测")]),s("br"),t._v("\n如果认为线性探测每次探测的步长为 1，探测序列为 hash(key)+0, hash(key)+1, hash(key)+2，则二次探测步长即为 hash(key)+0, hash(key)+1^2, hash(key)+2^2 ...")]),t._v(" "),s("p",[s("strong",[t._v("3. 双重散列")]),s("br"),t._v("\n使用多组散列函数，即存在 hash1(key), hash2(key), hash3(key) ...，使用时，先使用第一个散列函数，如果发现位置已被占用，再使用第二个散列函数，依次类推")]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"链表法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链表法"}},[t._v("#")]),t._v(" 链表法")]),t._v(" "),s("p",[t._v("使用链表法时，数组的每个位置可以视为一个「槽」，每个「槽」对应一条链表，当插入元素时，根据其散列值，找到对应的「槽」，将元素插入即可")]),t._v(" "),s("p",[t._v("此时插入时间复杂度为 O(1)，而查找、删除元素的复杂度取决于链表的长度 K，即 O(K)")]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("散列表碰撞攻击")]),t._v(" "),s("p",[t._v("通过精心设置的数据，使得所有数据经过散列后，都散列到同一个下标")])])])}),[],!1,null,null,null);a.default=_.exports}}]);